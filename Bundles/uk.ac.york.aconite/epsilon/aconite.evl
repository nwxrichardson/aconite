pre {
// "Running...".println();
var inDiagram = EAnnotation.all.select(i|i.source = "sirius.diagram").collect(i|i.getVal("name")).asSet();
var size = 0;
while (inDiagram.size() != size){
	size = inDiagram.size();
	inDiagram.addAll(EAnnotation.all.select(i|inDiagram.containsAll(i.getVals("container"))).collect(i|i.getVal("name")));
}
}

post {
// "Done...".println();
}

context EPackage {
	critique UniqueName {
		check {
		var names = EAnnotation.all.collect(i|i.details.get("name")).select(i|i.isTypeOf(String));
		names = names.reject(i|names.atMostNMatch(j|j = i,1));
		return names.size() = 0;
		}
		message : "One or more annotations share the name(s): " + names.asSet().toList()
	}
}

context EAnnotation {
	guard : not self.getVal("abstract").asBoolean()
	
	critique ContainerIsName {
		check : self.getVals("container") = Sequence{""} or self.getVals("container").forAll(i| EAnnotation.all.exists(j|j.getVal("name") = i))
		message : self.toAnno() + "container is not a name"
		}
	
	constraint ImportExists {
		check : self.details.get("extend") = "" or self.getVals("extend").forAll(i| EAnnotation.all.exists(j|j.getVal("name") = i))
		message : self.details.get("name") + '\'s import does not exist.'
	}
	
	constraint HasName {
		guard : self.source != "sirius"
		check : self.getVal("name") != ""
		message : self.toAnno() + " requires a name"
	}
	
	critique EdgeDirectlyInDiagram {
		guard : self.source = "sirius.edge"
		check : self.dirInDiagram()
		message : self.toAnno() + " edge not directly in diagram"
	}
	
	constraint ValidColor {
		guard : self.getVal("color") != "" 
		check : self.getVal("color").isColor()
		message : self.toAnno() + " has an invalid color"
	}
	
	constraint showIconIsBoolean{
		check : self.getVal("showIcon") = "" or self.getVal("showIcon").isBoolean()	
		message : "In" + self.toAnno() + "showIcon requires a Boolean"
	}
	
	constraint labelSizeIsInteger{
		check : self.getVal("labelSize") = "" or self.getVal("labelSize").isInteger()	
		message : "In" + self.toAnno() + "labelSize requires an Integer"
	}
	
	critique annotationNotInDiagram{
		guard : self.satisfies("ContainerIsName") and self.getVals("container") != Sequence{""}
		check : inDiagram.contains(self.getVal("name"))		
		message : self.toAnno() + "Not in diagram"
	}
}

operation EAnnotation getVals(key : String) : Sequence{
	var tmp = self.details.selectOne(i|i.key = key);
	if (tmp.isDefined()){
	return tmp.value.split(",").collect(i|i.trim());
	}
	return Sequence{""};
}

operation EAnnotation getVal(key : String) : String{

	var tmp = self.details.selectOne(i|i.key = key);
	if (tmp.isDefined()){
	return tmp.value;
	}
	return "";

}

operation String isBoolean() : Boolean{
	if (self = "true" or self = "false") {return true;} return false;
}

operation String isColor() : Boolean{
	var colors = Sequence{"black","white", "chocolate", "gray", "green", "orange", "purple", "red", "yellow", "blue" 
							, "light_chocolate", "light_gray", "light_green", "light_orange", "light_purple", "light_red", "light_yellow", "light_blue"
							, "dark_chocolate", "dark_gray", "dark_green", "dark_orange", "dark_purple", "dark_red", "dark_yellow", "dark_blue"};
	return colors.contains(self);
}

@cached
operation EAnnotation dirInDiagram() : Boolean {
	if (EAnnotation.all.select(i|i.source = "sirius.diagram").exists(i|self.getVals("container").exists(j|j = i.details.get("name")))) {return true;}
			if (self.getVal("container") = ""	){
				return self.getVals("extend").exists(i|EAnnotation.all.selectOne(j|j.getVal("name") = i).dirInDiagram());
			} return false;
}

operation EAnnotation toAnno() : String {
	var rtn = "@";
	rtn += self.source+ "{";
	for (entry : EStringToStringMapEntry in self.details){
		rtn += entry.key + " = " + entry.value + ", ";
	}
	rtn += "}";
	return rtn;
}

operation Set toList() : String {
	var rtn = "";
	var first = true;
	for (ele : String in self) {
		if (first) {rtn += ele; first = false;}
		else {rtn += ", " + ele;}
	} return rtn;
}


