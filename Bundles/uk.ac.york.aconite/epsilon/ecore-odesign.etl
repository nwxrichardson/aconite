import "config.eol";


/*
Add import properly
Fix Annotation statements with a function that offloads the getting of the right sources -> This woulld maybe have to check the equivalent type is a subtype 
Add supertypes to the automatic sourceNode and targetNode
Make the many container work and give them unique names afterwards (might require playing with id vs label)
Add edge description to allow for customising -> Look into if you are able to add any other versions
Fix creatable to be added at the end the same way as the tool shortcuts
Maybe make creatable the default
Make source and target try and figure out for themselves the same as sce
Future work would include separating the two versions
Allow @sirius to alter defaults?
Add Proxies to creatable and make everything a operation Maybe see if you can add proxies to references 
Pick nicer auto names and make one tool box for everything


Add within to options for container
template rather than import + fix it

Add some tests
*/


pre {
	"\nInitialising...".println();
	var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
	var hiddenTools = new Map<Target!AbstractToolDescription,Source!EAnnotation>;
	var annotations = Source.allContents.selectByType(Source!EAnnotation);
	for (i in annotations) {
		i.details.put("abstract", i.getVal("abstract"));
		if (i.details.containsKey("import")){
		
		var copyDetails = emfTool.getECoreUtil.copy(i).details;
		var imports =  i.getVals("import").invert();
		for (j in imports) {
			i.details.putAll(emfTool.getECoreUtil.copy(annotations.selectOne(k|k.getVal("name") = j)).details);
		}
		i.details.putAll(copyDetails);
		}
	}
	var randomStyle = new Target!SquareDescription;
	var colorPalette = randomStyle.color.eContainer.entries;
	delete randomStyle;
	"Running...".println();
}

@cached
operation getImgFolder() : String {
	return  annotations.selectOne(i|i.Source = "sirius").getVal("iconFolder");
} 

operation String makeImg() : String {
	if (self != "") {
	return getImgFolder() + self;
	} return "";
}

@cached
operation String getColor() : Target!SystemColor  {
	return colorPalette.selectOne(i|i.name = self);
}

@cached
operation Source!EAnnotation getDiagram() : Source!EAnnotation{
	if (self.Source = "sirius.diagram") {return self;}
	return annotations.selectOne(i|i.getVal("name") = self.getVal("container")).getDiagram();
}  

operation Source!EAnnotation getVal(key : String) : String{

	var tmp = self.details.selectOne(i|i.key = key);
	if (tmp.isDefined()){
	return tmp.value;
	}
	return self.getDefault(key);

}

operation Source!EAnnotation getVal(key : String, def : String) : String{

	var rtn = self.getVal(key);
	if (rtn != ""){return rtn;}
	return def;

}

operation Sequence<String> rtnVals() : String {
	var rtn = "";
	for (i in self){
		if ("" = rtn){
			rtn = i;
		} else {
			rtn += ", " + i;
		}
	}
	return rtn;
}

operation Source!EAnnotation getVals(key : String) : Sequence{
	var tmp = self.details.selectOne(i|i.key = key);
	if (tmp.isDefined()){
	return tmp.value.split(",").collect(i|i.trim());
	}
	return Sequence{""};
}
operation Source!EAnnotation getVals(key : String, def : String) : Sequence{
	var rtn = self.getVals(key);
	if (rtn != Sequence{""}){return rtn;}
	return Sequence(def);
}

operation Source!EClass getDC() : String {
	return self.ePackage.name + "::" + self.name;
}
	
operation Source!EClass getEndOf(expression : String) : Source!EClass{
	if (expression = ""){return self;}
	var splited = expression.split("\\.");
	if (splited.size() = 0){return self;}
	var rtn = self.getEAllReferences().selectOne(j|j.name = splited.get(0)).eType;
	if (splited.size() = 1){
	return rtn;}
	else {
	splited.remove(splited.get(0));
	return rtn.getEndOf(splited.concat());}
}

operation Target!AbstractToolDescription addToHidden(diagram : Source!EAnnotation){
	hiddenTools.put(self, diagram);
}

operation Target!AbstractToolDescription addToCreate(diagram : Source!EAnnotation){
	createTools.put(self, diagram);
}

operation Source!EClass oneRef(ref : String) : Boolean {
	return self.eAllReferences.selectOne(i|i.name = ref).oneRef();
}

operation Source!EReference oneRef() : Boolean {
	return self.upperBound = 1;
}

rule PackageFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!Group {
	
	guard : s.Source = "sirius"
	var viewpoint = new Target!Viewpoint;
	t.ownedViewpoints.add(viewpoint);
	var diagrams = annotations.select(i|i.Source = "sirius.diagram").equivalent();
	viewpoint.ownedRepresentations.addAll(diagrams);	
	viewpoint.name = s.getVal("name");
}



/*
 *----------------------------------------------------------------------------------
 *      SIRIUS ELEMENTS
 *----------------------------------------------------------------------------------
 */


@lazy
rule DiagramFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!DiagramDescription {
	
	guard : s.Source = "sirius.diagram" and not s.getVal("abstract").asBoolean()
	var element = s.eModelElement;
	t.domainClass = element.getDC();
	t.name = s.getVal("name");
	var defaultLayer = new Target!Layer;

	var tools = annotations.select(i|i.Source.startsWith("sirius.tool.creation") and i.getDiagram().getVal("name") = s.getVal("name") and not i.getVal("abstract").asBoolean());
	if (tools.notEmpty()){
		var toolBox = new Target!ToolSection;
		toolBox.name = "Generated Creation Tools";
		defaultLayer.toolSections.add(toolBox);
		toolBox.ownedTools ::= tools;
	}


	defaultLayer.name = "Default";
	t.defaultLayer = defaultLayer;
	defaultLayer.nodeMappings.addAll(annotations.select(i|i.getVal("container") = t.name).select(i|i.Source.startsWith("sirius.node")).equivalent());
	defaultLayer.edgeMappings.addAll(annotations.select(i|i.getVal("container") = t.name).select(i|i.Source.startsWith("sirius.edge")).equivalent());
	defaultLayer.containerMappings.addAll(annotations.select(i|i.getVal("container") = t.name).select(i|i.Source.startsWith("sirius.container")).equivalent());
	}
	
@abstract 
rule AbstractMappingFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!DiagramElementMapping {
	guard : not s.getVal("abstract").asBoolean()
	t.name = s.getVal("name");
	t.createElements = s.getVal("createElements").asBoolean;
	t.synchronizationLock = s.getVal("synchronizationLock").asBoolean;
	
	if (s.getVal("directlyEditable").asBoolean()){
		var directEdit = new Target!DirectEditLabel;
		directEdit.addToHidden(s.getDiagram());
		t.labelDirectEdit = directEdit;
		
		var init = new Target!InitialOperation;
		var set = new Target!SetValue;
		directEdit.initialOperation = init;
		init.firstModelOperations = set;
		set.featureName = s.getVal("labelExpression");
		set.valueExpression = "var:0";
	}
	} 

@abstract
rule AbstractNodeFromAnnotation 
	transform 	s : Source!EAnnotation
	to 			t : Target!AbstractNodeMapping 
	extends AbstractMappingFromAnnotation {
	var preStyled = emfTool.getECoreUtil.copy(annotations.select(i|i.source = s.source + ".description").selectOne(i|i.getVal("node") = s.getVal("name")));
	if (preStyled.isUndefined()){
	var styleAnnotation = emfTool.getECoreUtil.copy(s);
	styleAnnotation.Source = s.source + ".description" ;
	styleAnnotation.details.put("node", s.getVal("name"));
	t.style = styleAnnotation.equivalent();	
	} else {
	t.style = preStyled.equivalent();
	}
	
	}
	
@lazy
rule NodeFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!NodeMapping 
	extends SudoNodeFromAnnotation{
		guard : not s.Source.endsWith("import") and not s.Source.endsWith("description")
	}
	
@abstract
rule SudoNodeFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!NodeMapping 
	extends AbstractNodeFromAnnotation{
	
	guard : (s.Source.startsWith("sirius.node") or s.Source.startsWith("sirius.border"))
	
	var element = s.eModelElement;
	var container = annotations.selectOne(i|i.getVal("name") = s.getVal("container")).eModelElement;
	
	t.label = s.getVal("label", t.name);
	
	t.conditionnalStyles = annotations.select(i|i.Source = "sirius.condition" and i.getVal("node") = s.getVal("name")).equivalent("ConditionalNodeFromAnnotation");
	
	t.domainClass = element.getDC();
	t.semanticCandidatesExpression = "aql:self" + s.getVal("sce").dot();
	
	if (s.getVal("creatable").asBoolean()){
		var conRef = container.eAllReferences.selectOne(i|i.containment and i.eType.isSuperTypeOf(element));
		if (conRef.isDefined()){
			var create = new Target!NodeCreationDescription;
			create.initialOperation = new Target!InitialNodeCreationOperation;
			create.nodeMappings.add(t);
			create.name = "Create " + t.name + " in " + container.name;
			
			var changeContext = new Target!ChangeContext;
			create.initialOperation = new Target!InitialNodeCreationOperation;
			changeContext.browseExpression = "var:container";
			create.initialOperation.firstModelOperations = changeContext;
			
			var createIns = new Target!CreateInstance;
			createIns.referenceName = conRef.name;
			createIns.typeName = element.getDC();
			changeContext.subModelOperations.add(createIns);
			
			create.addToHidden(s.getDiagram());
		}
	}	
	
	}

@lazy
rule ContainerFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!ContainerMapping 
	extends SudoContainerFromAnnotation{
	guard : not s.Source.endsWith("import") and not s.Source.endsWith("description")	
	}
	
@abstract
rule SudoContainerFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!ContainerMapping 
	extends AbstractNodeFromAnnotation{
	
	guard : s.Source.startsWith("sirius.container")
	
	var element = s.eModelElement;
	var container = annotations.selectOne(i|i.getVal("name") = s.getVal("container")).eModelElement;
	
	t.label = s.getVal("label", t.name);
	
	t.conditionnalStyles = annotations.select(i|i.Source = "sirius.condition" and i.getVal("node") = s.getVal("name")).equivalent("ConditionalContainerFromAnnotation");
	
	t.domainClass = element.getDC();
	t.semanticCandidatesExpression = "aql:self" + s.getVal("sce").dot();
	
	t.subNodeMappings.addAll(annotations.select(i|i.getVal("container") = t.name).select(i|i.Source.startsWith("sirius.node")).equivalent());
	t.borderedNodeMappings.addAll(annotations.select(i|i.getVal("container") = t.name).select(i|i.Source = "sirius.border").equivalent());
	t.subContainerMappings.addAll(annotations.select(i|i.getVal("container") = t.name).select(i|i.Source.startsWith("sirius.container")).equivalent());
	
	t.childrenPresentation = Target!ContainerLayout#FreeForm.VALUES.selectOne(i|i.literal = s.getVal("childrenPresentation"));
	
	if (s.getVal("creatable").asBoolean()){
		var conRef = container.eAllReferences.selectOne(i|i.containment and i.eType.isSuperTypeOf(element));
		if (conRef.isDefined()){
			var create = new Target!ContainerCreationDescription;
			create.initialOperation = new Target!InitialNodeCreationOperation;
			create.containerMappings.add(t);
			create.name = "Create " + t.name + " in " + container.name;
			
			var changeContext = new Target!ChangeContext;
			create.initialOperation = new Target!InitialNodeCreationOperation;
			changeContext.browseExpression = "var:container";
			create.initialOperation.firstModelOperations = changeContext;
			
			var createIns = new Target!CreateInstance;
			createIns.referenceName = conRef.name;
			createIns.typeName = element.getDC();
			changeContext.subModelOperations.add(createIns);
			
			create.addToHidden(s.getDiagram());
		}
	}	
	
	}

@abstract
rule AbsEdgeFromAnnotation	
	transform 	s : Source!EAnnotation
	to 			t : Target!EdgeMapping 
	extends AbstractMappingFromAnnotation {
	guard : s.Source = "sirius.edge"
	
	t.conditionnalStyles = annotations.select(i|i.Source = "sirius.condition" and i.getVal("node") = s.getVal("name")).equivalent("ConditionalEdgeFromAnnotation");
	
	var preStyled = emfTool.getECoreUtil.copy(annotations.select(i|i.source = s.source + ".description").selectOne(i|i.getVal("edge") = s.getVal("name")));
	if (preStyled.isUndefined()){
		var styleAnnotation = emfTool.getECoreUtil.copy(s);
		styleAnnotation.Source = s.source + ".description" ;
		styleAnnotation.details.put("edge", s.getVal("name"));
		t.style = styleAnnotation.equivalent();	
	} else {
		t.style = preStyled.equivalent();
	}
	
	
	if (not (s.getVals("sourceNode") = Sequence{""})){
	t.sourceMapping = annotations.select(i|s.getVals("sourceNode").exists(j|j = i.getVal("name"))).equivalent();}
	if (not (s.getVals("targetNode")= Sequence{""})){
	t.targetMapping = annotations.select(i|s.getVals("targetNode").exists(j|j = i.getVal("name"))).equivalent();}	
	}
	
@lazy
rule RefEdgeFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!EdgeMapping 
	extends AbsEdgeFromAnnotation {
	guard : s.eModelElement.isTypeOf(Source!EReference)
	
	//TODO Make this work the way one would expect
	var element = s.eModelElement;
	var container = annotations.selectOne(i|i.getVal("name") = s.getVal("container")).eModelElement;
	t.label = s.getVal("label", t.name);
	if (t.sourceMapping.isEmpty()){
	t.sourceMapping = annotations.select(i|i.eModelElement = element.eContainingClass and i.Source != "sirius.diagram" and (not s.getVal("abstract").asBoolean())).equivalent();}

	t.targetFinderExpression = s.getVal("targetFinderExpression");	
	if (t.targetMapping.isEmpty()){
	t.targetMapping = annotations.select(i|i.eModelElement = element.eType.getEndOf(s.getVal("target")) and i.Source != "sirius.diagram").equivalent();}
	
	if (s.getVal("creatable").asBoolean()){
		var createEdge = new Target!EdgeCreationDescription;
		createEdge.name = "Add to " + s.eModelElement.name.ftuc();
		createEdge.addToHidden(s.getDiagram());
		createEdge.edgeMappings.add(t);
		var init = new Target!InitEdgeCreationOperation;
		createEdge.initialOperation = init;
		var chng = new Target!ChangeContext;
		init.firstModelOperations = chng;
		var set = new Target!SetValue;
		chng.subModelOperations.add(set);
		set.featureName = element.name;
		if (element.oneRef()){
			set.valueExpression = "aql:target";
		} else {
			set.valueExpression = "aql:self." + element.name + " + Sequence{target}";
		}
	}
	
	if (s.getVal("reconnectable").asBoolean()){
		var sourceConnect = new Target!ReconnectEdgeDescription;
		sourceConnect.addToHidden(s.getDiagram());
		
		sourceConnect.name = t.name + " Source Reconnector";
		t.reconnections.add(sourceConnect);
		sourceConnect.forceRefresh = true;
		sourceConnect.reconnectionKind = Target!ReconnectionKind#RECONNECT_SOURCE;
		
		var init = new Target!InitialOperation;
		sourceConnect.initialOperation = init;
		var chng = new Target!ChangeContext;
		init.firstModelOperations = chng;
		var sorc = new Target!ChangeContext;
		chng.subModelOperations.add(sorc);
		sorc.browseExpression = "aql:source";
		var uns = new Target!Unset;
		sorc.subModelOperations.add(uns);
		uns.featureName = element.name;
		uns.elementExpression = "aql:otherEnd.target";
		var targ = new Target!ChangeContext;
		targ.browseExpression = "aql:target";
		chng.subModelOperations.add(targ);
		var set = new Target!SetValue;
		targ.subModelOperations.add(set);
		set.featureName = element.name;
		if (element.oneRef()){
			set.valueExpression = "aql:target";
		} else {
			set.valueExpression = "aql:self." + element.name + " + Sequence{target}";
		}
		var targerConnect = new Target!ReconnectEdgeDescription;
		targerConnect.addToHidden(s.getDiagram());
		
		targerConnect.name = t.name + " Target Reconnector";
		t.reconnections.add(targerConnect);
		targerConnect.forceRefresh = true;
		targerConnect.reconnectionKind = Target!ReconnectionKind#RECONNECT_TARGET;
		
		var init = new Target!InitialOperation;
		targerConnect.initialOperation = init;
		var chng = new Target!ChangeContext;
		init.firstModelOperations = chng;

		var uns = new Target!Unset;
		uns.featureName = element.name;
		uns.elementExpression = "aql:source";
		var set = new Target!SetValue;
		set.featureName = element.name;
		if (element.oneRef()){
			set.valueExpression = "aql:target";
		} else {
			set.valueExpression = "aql:self." + element.name + " + Sequence{target}";
		}
		chng.subModelOperations.add(uns);
		chng.subModelOperations.add(set);
	}
	}
	
@lazy
rule EleEdgeFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!EdgeMapping 
	extends AbsEdgeFromAnnotation {
	
	guard : s.eModelElement.isTypeOf(Source!EClass)
	
	var element = s.eModelElement;
	var container = annotations.selectOne(i|i.getVal("name") = s.getVal("container")).eModelElement;

	t.label = s.getVal("label");
	
	t.useDomainElement = true;
	t.domainClass = element.getDC();
	//TODO
	t.sourceFinderExpression = s.getVal("sourceFinderExpression", "aql:self." +  s.getVal("source"));
	if (t.sourceMapping.isEmpty()){
	t.sourceMapping = annotations.select(i|i.eModelElement = element.getEndOf(s.getVal("source")) and i.Source != "sirius.diagram" and i.Source != "sirius.condition" and not i.Source.endsWith("description")).equivalent();}

	t.targetFinderExpression = s.getVal("targetFinderExpression");
	if (t.targetMapping.isEmpty()){
	//TODO Remove this work around
	t.targetMapping = annotations.select(i|i.eModelElement = element.getEndOf(s.getVal("target")) and i.Source != "sirius.diagram" and i.Source != "sirius.condition" and i.Source != "sirius.diagram" and not i.Source.endsWith("description")).equivalent();}
	//TODO make this a function
	if (s.getVal("creatable").asBoolean()){
		var conRef = container.eAllReferences.selectOne(i|i.containment and i.eType.isSuperTypeOf(element));
		if (conRef.isDefined()){
			var create = new Target!EdgeCreationDescription;
			create.initialOperation = new Target!InitEdgeCreationOperation;
			create.edgeMappings.add(t);
			create.name = "Create " + t.name + " in " + container.name;
			
			var changeContext = new Target!ChangeContext;
			changeContext.browseExpression = "aql:sourceView.getParentDiagram().target";
			create.initialOperation.firstModelOperations = changeContext;
			
			var createIns = new Target!CreateInstance;
			createIns.referenceName = conRef.name;
			createIns.typeName = element.getDC();
			changeContext.subModelOperations.add(createIns);
			var createSou = new Target!SetValue;
			createIns.subModelOperations.add(createSou);
			createSou.featureName = s.getVal("source");
			if (element.oneRef(s.getVal("source"))){
				createSou.valueExpression = "aql:source";
			} else {
				createSou.valueExpression = "aql:self." + s.getVal("source") + " + Sequence{source}";
			}
			
			var createTar = new Target!SetValue;
			createIns.subModelOperations.add(createTar);
			createTar.featureName = s.getVal("target");
			if (element.oneRef(s.getVal("target"))){
				createTar.valueExpression = "aql:target";
			} else {
				createTar.valueExpression = "aql:self." + s.getVal("target") + " + Sequence{target}";
			}
			
			create.addToHidden(s.getDiagram());
		}
	}	
	
	if (s.getVal("reconnectable").asBoolean()) {
		var sourceConnect = new Target!ReconnectEdgeDescription;
		sourceConnect.addToHidden(s.getDiagram());
		
		sourceConnect.name = t.name + " Source Reconnector";
		t.reconnections.add(sourceConnect);
		sourceConnect.forceRefresh = true;
		sourceConnect.reconnectionKind = Target!ReconnectionKind#RECONNECT_SOURCE;
		
		var init = new Target!InitialOperation;
		sourceConnect.initialOperation = init;
		var chng = new Target!ChangeContext;
		init.firstModelOperations = chng;
		
		var uns = new Target!Unset;
		uns.featureName = s.getVal("source");
		uns.elementExpression = "aql:source";
		var set = new Target!SetValue;
		set.featureName = s.getVal("source");
		if (element.oneRef(s.getVal("source"))){
			set.valueExpression = "aql:target";
		} else {
			set.valueExpression = "aql:self." + s.getVal("source") + " + Sequence{target}";
		}
		chng.subModelOperations.add(uns);
		chng.subModelOperations.add(set);
		
		var targerConnect = new Target!ReconnectEdgeDescription;
		targerConnect.addToHidden(s.getDiagram());
		
		targerConnect.name = t.name + " Target Reconnector";
		t.reconnections.add(targerConnect);
		targerConnect.forceRefresh = true;
		targerConnect.reconnectionKind = Target!ReconnectionKind#RECONNECT_TARGET;
		
		var init = new Target!InitialOperation;
		targerConnect.initialOperation = init;
		var chng = new Target!ChangeContext;
		init.firstModelOperations = chng;
	
		var uns = new Target!Unset;
		uns.featureName = s.getVal("target");
		uns.elementExpression = "aql:source";
		var set = new Target!SetValue;
		set.featureName = s.getVal("target");
		if (element.oneRef(s.getVal("target"))){
			set.valueExpression = "aql:target";
		} else {
			set.valueExpression = "aql:self." + s.getVal("target") + " + Sequence{target}";
		}
		chng.subModelOperations.add(uns);
		chng.subModelOperations.add(set);
	}
}

/*
 *----------------------------------------------------------------------------------
 *      CONDITIONAL STYLES
 *----------------------------------------------------------------------------------
 */	

@abstarct
rule ConditionalFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!ConditionalStyleDescription {
	guard : s.Source = "sirius.condition"
	t.predicateExpression = s.getVal("condition");
	} 
	
@lazy
rule ConditionalNodeFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!ConditionalNodeStyleDescription 
	extends ConditionalFromAnnotation {
		 t.style = annotations.selectOne(i|i.Source = "sirius.node.description" and i.getVal("node") = s.getVal("name")).equivalent();
	} 

@lazy
rule ConditionalContainerFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!ConditionalContainerStyleDescription 
	extends ConditionalFromAnnotation {
		 t.style = annotations.selectOne(i|i.Source = "sirius.container.description" and i.getVal("node") = s.getVal("name")).equivalent();
	} 
	
@lazy
rule ConditionalContainerFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!ConditionalEdgeStyleDescription 
	extends ConditionalFromAnnotation {
		 t.style = annotations.selectOne(i|i.Source = "sirius.edge.description" and i.getVal("node") = s.getVal("name")).equivalent();
	} 

/*
 *----------------------------------------------------------------------------------
 *      SHORTCUT TOOLS
 *----------------------------------------------------------------------------------
 */	


@abstract
rule ReferenceCreationToolFromAnnotation
	transform s : Source!EAnnotation 
	to t : Target!MappingBasedToolDescription {
	guard : s.Source = "sirius.tool.creation.reference" and not s.getVal("abstract").asBoolean()
	t.forceRefresh = true;
	t.name = "Add to " + s.eModelElement.name.ftuc();
	}

@lazy
rule ContainerReferenceCreationToolFromAnnotation
	transform s : Source!EAnnotation
	to t : Target!ToolDescription 
	extends ReferenceCreationToolFromAnnotation {
	guard : s.getVal("container") != ""
	
	var p = annotations.selectOne(i|i.getVal("name") = s.getVal("container"));
	t.precondition = "aql:elementView.actualMapping.name = '" + annotations.selectOne(i|i.getVal("name") = p.getVal("container")).equivalent().name + "'";
	var changeContext = new Target!ChangeContext;
	t.initialOperation = new Target!InitialOperation;
	t.initialOperation.firstModelOperations = changeContext;
	if (s.getVal("proxyType") =  "Container"){changeContext.browseExpression = "aql:element.eContainer()";}
	if (s.getVal("proxyType") =  "Diagram"){changeContext.browseExpression = "aql:diagram.target";}
	if (s.getVal("proxyType") =  "Personal"){changeContext.browseExpression = s.getVal("proxyStatement");}
	
	var create = new Target!CreateInstance;
	create.referenceName = p.eModelElement.name;
	create.typeName = p.eModelElement.eReferenceType.getDC();
	changeContext.subModelOperations.add(create);
	
	var refContext = new Target!ChangeContext;
	refContext.browseExpression = "aql:element";
	changeContext.subModelOperations.add(refContext);
	//TODO Check that this works if it is only able to hold one reference
	var setRef = new Target!SetValue;
	setRef.featureName = s.eModelElement.name;
	setRef.valueExpression = "aql: element." + s.eModelElement.name + " + Sequence{instance}";
	refContext.subModelOperations.add(setRef);
	}

@abstract
rule CreationToolFromAnnotation
	transform s : Source!EAnnotation 
	to t : Target!MappingBasedToolDescription {
	guard : s.Source = "sirius.tool.creation" and not s.getVal("abstract").asBoolean()
	t.forceRefresh = true;
	t.name = "Add to " + s.getVal("name").ftuc();
	}

@lazy
rule ContainerCreationToolFromAnnotation
	transform s : Source!EAnnotation
	to t : Target!ContainerCreationDescription 
	extends CreationToolFromAnnotation {
	guard : s.getVal("container") != "" and annotations.selectOne(i|i.getVal("name") = s.getVal("container")).Source = "sirius.container"
	var element = annotations.select(i|i.getVal("name") = s.getVal("container"));
	t.containerMappings = element.equivalent();
	var changeContext = new Target!ChangeContext;
	t.initialOperation = new Target!InitialNodeCreationOperation;
	changeContext.browseExpression = "var:container";
	t.initialOperation.firstModelOperations = changeContext;
	var create = new Target!CreateInstance;
	create.referenceName = s.eModelElement.name;
	create.typeName = element.random().eModelElement.getDC();
	changeContext.subModelOperations.add(create);
	}
	
@lazy
rule NodeCreationToolFromAnnotation
	transform s : Source!EAnnotation
	to t : Target!NodeCreationDescription 
	extends CreationToolFromAnnotation {
	guard : s.getVal("container") != "" and annotations.selectOne(i|i.getVal("name") = s.getVal("container")).Source = "sirius.node"
	var element = annotations.select(i|i.getVal("name") = s.getVal("container"));
	t.nodeMappings = element.equivalent();
	var changeContext = new Target!ChangeContext;
	t.initialOperation = new Target!InitialNodeCreationOperation;
	changeContext.browseExpression = "var:container";
	t.initialOperation.firstModelOperations = changeContext;
	var create = new Target!CreateInstance;
	create.referenceName = s.eModelElement.name;
	create.typeName = element.random().eModelElement.getDC();
	changeContext.subModelOperations.add(create);
	}

/*
 *----------------------------------------------------------------------------------
 *      SIRIUS IMPORTS
 *----------------------------------------------------------------------------------
 */	

@abstract
rule AbstractMappingImportFromAnnotation
	transform s : Source!EAnnotation
	to t : Target!AbstractMappingImport{
	guard : s.Source.endsWith("import")
	t.hideSubMappings = s.getVal("hideSubMappings").asBoolean();
	t.inheritsAncestorFilters = s.getVal("inheritsAncestorFilters").asBoolean();
	}

@lazy
rule ImportNodeFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!NodeMappingImport
	extends SudoNodeFromAnnotation, AbstractMappingImportFromAnnotation{
	guard : s.Source.startsWith("sirius.node")
	t.importedMapping = annotations.select(i|i.getVal("name") = s.getVal("importedMapping")).selectOne(i|i.Source = "sirius.node").equivalent();
	}
	
@lazy
rule ImportContainerFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!ContainerMappingImport
	extends SudoContainerFromAnnotation, AbstractMappingImportFromAnnotation{
	guard : s.Source.startsWith("sirius.container")
	t.importedMapping = annotations.select(i|i.getVal("name") = s.getVal("importedMapping")).selectOne(i|i.Source = "sirius.container").equivalent();
	}

/*
 *----------------------------------------------------------------------------------
 *      ABSTRACT META SIRIUS STYLES 
 *----------------------------------------------------------------------------------
 */	

@abstract
rule BorderedStyleFromAnnotation
	transform s : Source!EAnnotation
	to t : Target!BorderedStyleDescription{
	t.borderColor = s.getVal("borderColor").getColor();
	t.borderLineStyle = Target!LineStyle#dot.VALUES.selectOne(i|i.literal = s.getVal("borderLineStyle"));
	t.borderSizeComputationExpression = "aql:" + s.getVal("borderSize");
	}
	
@abstract
rule LabelStyleFromAnnotation
	transform s : Source!EAnnotation
	to t : Target!LabelStyleDescription{
	t.iconPath = s.getVal("iconPath").makeImg();
	t.labelAlignment = Target!LabelAlignment#CENTER.VALUES.selectOne(i|i.literal = s.getVal("labelAlignment"));
	t.labelColor = s.getVal("labelColor").getColor();
	t.labelExpression = s.getVal("labelValue");
	t.labelFormat = Target!FontFormat#bold.VALUES.select(i|s.getVals("borderLineStyle").exists(j|j = i.literal));
	t.labelSize = s.getVal("labelSize").asInteger();
	t.showIcon = s.getVal("showIcon").asBoolean();
	}

@abstract
rule TooltipFromAnnotation
	transform s : Source!EAnnotation
	to t : Target!TooltipStyleDescription{
	t.tooltipExpression = s.getVal("tooltip");
	}
	
@abstract
rule RoundedCornerFromAnnotation
	transform s : Source!EAnnotation
	to t : Target!TooltipStyleDescription{
	t.arcHeight = s.getVal("arcHeight").asInteger();
	t.arcWidth = s.getVal("arcWidth").asInteger();
	}

/*
 *----------------------------------------------------------------------------------
 *      ABSTRACT SIRIUS STYLES 
 *----------------------------------------------------------------------------------
 */	

@abstract
rule NodeStyleFromAnnotation
	transform s : Source!EAnnotation
	to t : Target!NodeStyleDescription
	extends BorderedStyleFromAnnotation, LabelStyleFromAnnotation , TooltipFromAnnotation
	{
	guard : (s.source = "sirius.node.description" or s.source = "sirius.border.description") and (not s.getVal("abstract").asBoolean())
	t.forbiddenSides = Target!Side#NORTH.VALUES.select(i|s.getVals("forbiddenSides").exists(j|j = i.literal));
 	t.hideLabelByDefault = s.getVal("hideLabelByDefault").asBoolean();
 	t.iconPath = s.getVal("iconPath");
 	t.labelPosition = Target!LabelPosition#node.VALUES.selectOne(i|i.literal = s.getVal("labelPosition"));
 	t.resizeKind = Target!ResizeKind#NSEW.VALUES.selectOne(i|i.literal = s.getVal("resizeKind"));
	t.sizeComputationExpression = s.getVal("sizeComputationExpression");
	}
		
@abstract
rule ContainerStyleFromAnnotation
	transform s : Source!EAnnotation
	to t : Target!ContainerStyleDescription
	extends BorderedStyleFromAnnotation, LabelStyleFromAnnotation , TooltipFromAnnotation , RoundedCornerFromAnnotation
	{
	guard : s.source = "sirius.container.description" and not s.getVal("abstract").asBoolean()
 	t.hideLabelByDefault = s.getVal("hideLabelByDefault","false").asBoolean();
 	t.iconPath = s.getVal("iconPath");
	t.heightComputationExpression = s.getVal("heightComputationExpression");
	t.widthComputationExpression = s.getVal("widthComputationExpression");
	t.roundedCorner = s.getVal("roundedCorner").asBoolean();

	}
	
/*
 *----------------------------------------------------------------------------------
 *      SIRIUS STYLES 
 *----------------------------------------------------------------------------------
 */		
	
@lazy
rule EdgeStyleFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!EdgeStyleDescription{
	guard : s.source = "sirius.edge.description" and not s.getVal("abstract").asBoolean()	
		t.endsCentering = Target!CenteringStyle#Both.VALUES.selectOne(i|i.literal = s.getVal("endsCentering"));
		t.sourceArrow = Target!EdgeArrows#NoDecoration.VALUES.selectOne(i|i.literal = s.getVal("sourceArrow"));
		t.targetArrow = Target!EdgeArrows#NoDecoration.VALUES.selectOne(i|i.literal = s.getVal("target	Arrow"));
		var label = s.getVal("labelExpression");
		if (label != ""){
			t.centerLabelStyleDescription = new Target!CenterLabelStyleDescription;
			t.centerLabelStyleDescription.labelExpression = "aql:self." + label;
			t.centerLabelStyleDescription.showIcon = false;
		}
		t.strokeColor = s.getVal("color").getColor();
	}	
	
@lazy
rule FlatContainerFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!FlatContainerStyleDescription 
	extends ContainerStyleFromAnnotation{
	guard : s.getVal("shape") = "flat" or s.getVal("shape") = ""
	
	t.backgroundColor = s.getVal("backgroundColor").getColor();
	t.foregroundColor = s.getVal("foregroundColor").getColor();
	t.backgroundStyle = Target!BackgroundStyle#Liquid.VALUES.selectOne(i|i.literal = s.getVal("backgroundStyle","GradientLeftToRight"));
	
	}
	
@lazy
rule ShapeContainerFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!ShapeContainerStyleDescription 
	extends ContainerStyleFromAnnotation{
	guard : s.getVal("shape") = "shape"
	
	t.backgroundColor = s.getVal("color", "lightYellow").getColor();
	//Pointless
	t.shape = Target!ContainerShape#parallelogram.VALUES.selectOne(i|i.literal = s.getVal("shape","parallelogram"));
	
	}

@lazy
rule SquareNodeFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!SquareDescription 
	extends NodeStyleFromAnnotation{
	guard : s.getVal("shape") = "square" or s.getVal("shape") = ""
	
	t.color = s.getVal("color").getColor();
	t.height = s.getVal("height").asInteger();
	t.width = s.getVal("width").asInteger();
	
	}
	
@lazy
rule DotNodeFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!DotDescription 
	extends NodeStyleFromAnnotation{
	guard : s.getVal("shape") = "dot"
	
	t.backgroundColor = s.getVal("color").getColor();
	t.strokeSizeComputationExpression = s.getVal("strokeSizeComputationExpression","2");
	}
	
@lazy
rule EllipseNodeFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!EllipseNodeDescription 
	extends NodeStyleFromAnnotation{
	guard : s.getVal("shape") = "ellipse"
	//Maybe make a colourable rule
	t.color = s.getVal("color").getColor();
	t.horizontalDiameterComputationExpression = s.getVal("horizontalDiameterComputationExpression","2");
	t.verticalDiameterComputationExpression = s.getVal("verticalDiameterComputationExpression","2");
	}
	
//@lazy
//rule GaugeNodeFromAnnotation
//	transform 	s : Source!EAnnotation
//	to 			t : Target!GuageDescription 
//	extends NodeStyleFromAnnotation{
//	guard : s.getVal("shape") = "ellipse"
//	
//	t.alightment Enum
//	}

@lazy
rule LozengeNodeFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!LozengeNodeDescription 
	extends NodeStyleFromAnnotation{
	guard : s.getVal("shape") = "ellipse"
	//Maybe make a colourable rule
	t.color = s.getVal("color").getColor();
	t.heightComputationExpression = s.getVal("heightComputationExpression","2");
	t.widthComputationExpression = s.getVal("widthComputationExpression","2");
	}
	
@lazy
rule WorkspaceImageNodeFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!WorkspaceImageDescription
	extends NodeStyleFromAnnotation
{
	guard : s.getVal("shape") = "image"
	
	t.workspacePath = s.getVal("imagePath").makeImg();
	}

	
post {
	var gotHidden = new Sequence;
	for (tool in hiddenTools.keySet()){
		if (not gotHidden.contains(hiddenTools.get(tool))){
			gotHidden.add(hiddenTools.get(tool));
			var hiddenBox = new Target!ToolSection;
			hiddenBox.name = "Generated Hidden Tools";
			hiddenTools.get(tool).equivalent().defaultLayer.toolSections.add(hiddenBox);
		}
		hiddenTools.get(tool).equivalent().defaultLayer.toolSections.selectOne(i|i.name = "Generated Hidden Tools").ownedTools.add(tool);
	}
	"Done!".println();
}	