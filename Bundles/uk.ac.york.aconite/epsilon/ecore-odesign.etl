import "config.eol";

pre {
	var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
	var hiddenTools = new Map<Target!AbstractToolDescription,Source!EAnnotation>;
	var annotations = Source.allContents.selectByType(Source!EAnnotation);
	for (i in annotations) {
		i.details.put("abstract", i.getVal("abstract"));
		if (i.details.containsKey("import")){
		
		var copyDetails = emfTool.getECoreUtil.copy(i).details;
		var imports =  i.getVals("import").invert();
		for (j in imports) {
			i.details.putAll(emfTool.getECoreUtil.copy(annotations.selectOne(k|k.getVal("name") = j)).details);
		}
		i.details.putAll(copyDetails);
		}
	}
	var newAnnotations = new Sequence;
	var revAnnotations = new Sequence;
	for (i in annotations){
		var containers = i.getVals("container");
		if (containers.size() != 1){
			for (j in containers){
				var `new` = emfTool.getECoreUtil.copy(i);
				`new`.details.put("container",j);
				`new`.eModelElement = i.eModelElement;
				`new`.details.selectOne(i|i.key = 'name').value = j.ftuc() + " - " + `new`.getVal("name");
				newAnnotations.add(`new`);
			} revAnnotations.add(i);
		} 
	} annotations.addAll(newAnnotations);
	annotations.removeAll(revAnnotations);
	var randomStyle = new Target!SquareDescription;
	var colorPalette = randomStyle.color.eContainer.entries;
	delete randomStyle;
	annotations.details.println();
}

@cached
operation String getColor() : Target!SystemColor  {
	return colorPalette.selectOne(i|i.name = self);
}

operation Source!EAnnotation getDiagram() : Source!EAnnotation{
	if (self.Source = "sirius.diagram") {return self;}
	return annotations.selectOne(i|i.getVal("name") = self.getVal("container")).getDiagram();
}  

operation Source!EAnnotation getVal(key : String) : String{

	var tmp = self.details.selectOne(i|i.key = key);
	if (tmp.isDefined()){
	return tmp.value;
	}
	return self.getDefault(key);

}

operation Source!EAnnotation getVal(key : String, def : String) : String{

	var rtn = self.getVal(key);
	if (rtn != ""){return rtn;}
	return def;

}


operation Source!EAnnotation getVals(key : String) : Sequence{
	var tmp = self.details.selectOne(i|i.key = key);
	if (tmp.isDefined()){
	return tmp.value.split(",").collect(i|i.trim());
	}
	return Sequence{""};
}
operation Source!EAnnotation getVals(key : String, def : String) : Sequence{
	var rtn = self.getVals(key);
	if (rtn != Sequence{""}){return rtn;}
	return Sequence(def);
}

operation Source!EClass getDC() : String {
	return self.ePackage.name + "::" + self.name;
}
	
operation Source!EClass getEndOf(expression : String) : Source!EClass{
	if (expression = ""){return self;}
	var splited = expression.split("\\.");
	if (splited.size() = 0){return self;}
	var rtn = self.getEAllReferences().selectOne(j|j.name = splited.get(0)).eType;
	if (splited.size() = 1){
	return rtn;}
	else {
	splited.remove(splited.get(0));
	return rtn.getEndOf(splited.concat());}
}

operation Target!AbstractToolDescription addToHidden(diagram : Source!EAnnotation){
	hiddenTools.put(self, diagram);
}

operation Source!EClass oneRef(ref : String) : Boolean {
	return self.eReferences.selectOne(i|i.name = 'person').oneRef();
}

operation Source!EReference oneRef() : Boolean {
	return self.upperBound = 1;
}

rule PackageFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!Group {
	
	guard : s.Source = "sirius"
	var viewpoint = new Target!Viewpoint;
	t.ownedViewpoints.add(viewpoint);
	var diagrams = annotations.select(i|i.Source = "sirius.diagram").equivalent();
	viewpoint.ownedRepresentations.addAll(diagrams);	
	viewpoint.name = s.getVal("name");
}



/*
 *----------------------------------------------------------------------------------
 *      SIRIUS ELEMENTS
 *----------------------------------------------------------------------------------
 */


@lazy
rule DiagramFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!DiagramDescription {
	
	guard : s.Source = "sirius.diagram" and not s.getVal("abstract").asBoolean()
	var element = s.eModelElement;
	t.domainClass = element.getDC();
	t.name = s.getVal("name");
	var defaultLayer = new Target!Layer;

	var tools = annotations.select(i|i.Source.startsWith("sirius.tool.creation") and i.getDiagram().getVal("name") = s.getVal("name") and not i.getVal("abstract").asBoolean());
	if (tools.notEmpty()){
		var toolBox = new Target!ToolSection;
		toolBox.name = "Generated Creation Tools";
		defaultLayer.toolSections.add(toolBox);
		toolBox.ownedTools ::= tools;
	}


	defaultLayer.name = "Default";
	t.defaultLayer = defaultLayer;
	defaultLayer.nodeMappings.addAll(annotations.select(i|i.getVal("container") = t.name).select(i|i.Source = "sirius.node").equivalent());
	defaultLayer.edgeMappings.addAll(annotations.select(i|i.getVal("container") = t.name).select(i|i.Source = "sirius.edge").equivalent());
	defaultLayer.containerMappings.addAll(annotations.select(i|i.getVal("container") = t.name).select(i|i.Source = "sirius.container").equivalent());

	}
	
@abstract 
rule AbstractMappingFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!DiagramElementMapping {
	guard : not s.getVal("abstract").asBoolean()
	t.name = s.getVal("name");
	t.createElements = s.getVal("createElements").asBoolean;
	t.synchronizationLock = s.getVal("synchronizationLock").asBoolean;
	
	if (s.getVal("directlyEditable").asBoolean()){
		var directEdit = new Target!DirectEditLabel;
		directEdit.addToHidden(s.getDiagram());
		t.labelDirectEdit = directEdit;
		
		var init = new Target!InitialOperation;
		var set = new Target!SetValue;
		directEdit.initialOperation = init;
		init.firstModelOperations = set;
		set.featureName = s.getVal("labelExpression");
		set.valueExpression = "var:0";
	}
	} 

@abstract
rule AbstractNodeFromAnnotation 
	transform 	s : Source!EAnnotation
	to 			t : Target!AbstractNodeMapping 
	extends AbstractMappingFromAnnotation {
	var preStyled = emfTool.getECoreUtil.copy(annotations.select(i|i.source = s.source + ".description").selectOne(i|i.getVal("node") = s.getVal("name")));
	if (preStyled.isUndefined()){
	var styleAnnotation = emfTool.getECoreUtil.copy(s);
	styleAnnotation.Source = s.source + ".description" ;
	styleAnnotation.details.put("node", s.getVal("name"));
	t.style = styleAnnotation.equivalent();	
	} else {
	t.style = preStyled.equivalent();
	}
	
	}
	
@lazy
rule NodeFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!NodeMapping 
	extends AbstractNodeFromAnnotation{
	
	guard : (s.Source.startsWith("sirius.node") or s.Source.startsWith("sirius.border")) and not s.Source.endsWith("description")
	
	var element = s.eModelElement;
	var container = annotations.selectOne(i|i.getVal("name") = s.getVal("container")).eModelElement;
	
	t.label = s.getVal("label", t.name);
	
	t.conditionnalStyles = annotations.select(i|i.Source = "sirius.condition" and i.getVal("node") = s.getVal("name")).equivalent("ConditionalNodeFromAnnotation");
	
	t.domainClass = element.getDC();
	t.semanticCandidatesExpression = "aql:self" + s.getVal("sce").dot();
	
	}
	
@lazy
rule ContainerFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!ContainerMapping 
	extends AbstractNodeFromAnnotation{
	
	guard : s.Source = "sirius.container"
	
	var element = s.eModelElement;
	var container = annotations.selectOne(i|i.getVal("name") = s.getVal("container")).eModelElement;
	
	t.label = s.getVal("label", t.name);
	
	t.conditionnalStyles = annotations.select(i|i.Source = "sirius.condition" and i.getVal("node") = s.getVal("name")).equivalent("ConditionalContainerFromAnnotation");
	
	t.domainClass = element.getDC();
	t.semanticCandidatesExpression = "aql:self" + s.getVal("sce").dot();
	
	t.subNodeMappings.addAll(annotations.select(i|i.getVal("container") = t.name).select(i|i.Source = "sirius.node").equivalent());
	t.borderedNodeMappings.addAll(annotations.select(i|i.getVal("container") = t.name).select(i|i.Source = "sirius.border").equivalent());
	t.subContainerMappings.addAll(annotations.select(i|i.getVal("container") = t.name).select(i|i.Source = "sirius.container").equivalent());
	
	t.childrenPresentation = Target!ContainerLayout#FreeForm.VALUES.selectOne(i|i.literal = s.getVal("childrenPresentation"));
	}

@abstract
rule AbsEdgeFromAnnotation	
	transform 	s : Source!EAnnotation
	to 			t : Target!EdgeMapping 
	extends AbstractMappingFromAnnotation {
	guard : s.Source = "sirius.edge"
	
	t.conditionnalStyles = annotations.select(i|i.Source = "sirius.condition" and i.getVal("node") = s.getVal("name")).equivalent("ConditionalEdgeFromAnnotation");
	
	t.style = new Target!EdgeStyleDescription;	
	t.style.endsCentering = Target!CenteringStyle#Both;
	if (not (s.getVals("sourceNode") = Sequence{""})){
	t.sourceMapping = annotations.select(i|s.getVals("sourceNode").exists(j|j = i.getVal("name")) ).equivalent();}
	if (not (s.getVals("targetNode")= Sequence{""})){
	t.targetMapping = annotations.select(i|s.getVals("targetNode").exists(j|j = i.getVal("name"))).equivalent();}	
	
	var label = s.getVal("labelExpression");
	if (label != ""){
	t.style.centerLabelStyleDescription = new Target!CenterLabelStyleDescription;
	t.style.centerLabelStyleDescription.labelExpression = "aql:self." + label;
	t.style.centerLabelStyleDescription.showIcon = false;
	}
	t.style.strokeColor = s.getVal("color").getColor();
	}
	
@lazy
rule RefEdgeFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!EdgeMapping 
	extends AbsEdgeFromAnnotation {
	guard : s.eModelElement.isTypeOf(Source!EReference)
	
	//TODO Make this work the way one would expect
	var element = s.eModelElement;
	var container = annotations.selectOne(i|i.getVal("name") = s.getVal("container")).eModelElement;
	t.label = s.getVal("label", t.name);
	if (t.sourceMapping.isEmpty()){
	t.sourceMapping = annotations.select(i|i.eModelElement = element.eContainingClass and i.Source != "sirius.diagram" and (not s.getVal("abstract").asBoolean())).equivalent();}

	t.targetFinderExpression = s.getVal("targetFinderExpression");	
	if (t.targetMapping.isEmpty()){
	t.targetMapping = annotations.select(i|i.eModelElement = element.eType.getEndOf(s.getVal("target")) and i.Source != "sirius.diagram").equivalent();}
	
	if (s.getVal("creatable").asBoolean()){
		var createEdge = new Target!EdgeCreationDescription;
		createEdge.name = "Add to " + s.eModelElement.name.ftuc();
		createEdge.addToHidden(s.getDiagram());
		createEdge.edgeMappings.add(t);
		var init = new Target!InitEdgeCreationOperation;
		createEdge.initialOperation = init;
		var chng = new Target!ChangeContext;
		init.firstModelOperations = chng;
		var set = new Target!SetValue;
		chng.subModelOperations.add(set);
		set.featureName = element.name;
		if (element.oneRef()){
			set.valueExpression = "aql:target";
		} else {
			set.valueExpression = "aql:self." + element.name + " + Sequence{target}";
		}
	}
	
	if (s.getVal("reconnectable").asBoolean()){
		var sourceConnect = new Target!ReconnectEdgeDescription;
		sourceConnect.addToHidden(s.getDiagram());
		
		sourceConnect.name = t.name + " Source Reconnector";
		t.reconnections.add(sourceConnect);
		sourceConnect.forceRefresh = true;
		sourceConnect.reconnectionKind = Target!ReconnectionKind#RECONNECT_SOURCE;
		
		var init = new Target!InitialOperation;
		sourceConnect.initialOperation = init;
		var chng = new Target!ChangeContext;
		init.firstModelOperations = chng;
		var sorc = new Target!ChangeContext;
		chng.subModelOperations.add(sorc);
		sorc.browseExpression = "aql:source";
		var uns = new Target!Unset;
		sorc.subModelOperations.add(uns);
		uns.featureName = element.name;
		uns.elementExpression = "aql:otherEnd.target";
		var targ = new Target!ChangeContext;
		targ.browseExpression = "aql:target";
		chng.subModelOperations.add(targ);
		var set = new Target!SetValue;
		targ.subModelOperations.add(set);
		set.featureName = element.name;
		if (element.oneRef()){
			set.valueExpression = "aql:target";
		} else {
			set.valueExpression = "aql:self." + element.name + " + Sequence{target}";
		}
		var targerConnect = new Target!ReconnectEdgeDescription;
		targerConnect.addToHidden(s.getDiagram());
		
		targerConnect.name = t.name + " Target Reconnector";
		t.reconnections.add(targerConnect);
		targerConnect.forceRefresh = true;
		targerConnect.reconnectionKind = Target!ReconnectionKind#RECONNECT_TARGET;
		
		var init = new Target!InitialOperation;
		targerConnect.initialOperation = init;
		var chng = new Target!ChangeContext;
		init.firstModelOperations = chng;

		var uns = new Target!Unset;
		uns.featureName = element.name;
		uns.elementExpression = "aql:source";
		var set = new Target!SetValue;
		set.featureName = element.name;
		if (element.oneRef()){
			set.valueExpression = "aql:target";
		} else {
			set.valueExpression = "aql:self." + element.name + " + Sequence{target}";
		}
		chng.subModelOperations.add(uns);
		chng.subModelOperations.add(set);
	}
	}
	
@lazy
rule EleEdgeFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!EdgeMapping 
	extends AbsEdgeFromAnnotation {
	
	guard : s.eModelElement.isTypeOf(Source!EClass)
	
	var element = s.eModelElement;
	var container = annotations.selectOne(i|i.getVal("name") = s.getVal("container")).eModelElement;

	t.label = s.getVal("label");
	
	t.useDomainElement = true;
	t.domainClass = element.getDC();
	//TODO
	t.sourceFinderExpression = s.getVal("sourceFinderExpression", "aql:self." +  s.getVal("source"));
	if (t.sourceMapping.isEmpty()){
	t.sourceMapping = annotations.select(i|i.eModelElement = element.getEndOf(s.getVal("source")) and i.Source != "sirius.diagram" and i.Source != "sirius.condition" and not i.Source.endsWith("description")).equivalent();}

	t.targetFinderExpression = s.getVal("targetFinderExpression");
	if (t.targetMapping.isEmpty()){
	//TODO Remove this work around
	t.targetMapping = annotations.select(i|i.eModelElement = element.getEndOf(s.getVal("target")) and i.Source != "sirius.diagram" and i.Source != "sirius.condition" and i.Source != "sirius.diagram" and not i.Source.endsWith("description")).equivalent();}
	//TODO make this a function
	if (s.getVal("reconnectable").asBoolean()) {
		var sourceConnect = new Target!ReconnectEdgeDescription;
		sourceConnect.addToHidden(s.getDiagram());
		
		sourceConnect.name = t.name + " Source Reconnector";
		t.reconnections.add(sourceConnect);
		sourceConnect.forceRefresh = true;
		sourceConnect.reconnectionKind = Target!ReconnectionKind#RECONNECT_SOURCE;
		
		var init = new Target!InitialOperation;
		sourceConnect.initialOperation = init;
		var chng = new Target!ChangeContext;
		init.firstModelOperations = chng;
		
		var uns = new Target!Unset;
		uns.featureName = s.getVal("source");
		uns.elementExpression = "aql:source";
		var set = new Target!SetValue;
		set.featureName = s.getVal("source");
		if (element.oneRef(s.getVal("source"))){
			set.valueExpression = "aql:target";
		} else {
			set.valueExpression = "aql:self." + s.getVal("source") + " + Sequence{target}";
		}
		chng.subModelOperations.add(uns);
		chng.subModelOperations.add(set);
		
		var targerConnect = new Target!ReconnectEdgeDescription;
		targerConnect.addToHidden(s.getDiagram());
		
		targerConnect.name = t.name + " Target Reconnector";
		t.reconnections.add(targerConnect);
		targerConnect.forceRefresh = true;
		targerConnect.reconnectionKind = Target!ReconnectionKind#RECONNECT_TARGET;
		
		var init = new Target!InitialOperation;
		targerConnect.initialOperation = init;
		var chng = new Target!ChangeContext;
		init.firstModelOperations = chng;
	
		var uns = new Target!Unset;
		uns.featureName = s.getVal("target");
		uns.elementExpression = "aql:source";
		var set = new Target!SetValue;
		set.featureName = s.getVal("target");
		if (element.oneRef(s.getVal("target"))){
			set.valueExpression = "aql:target";
		} else {
			set.valueExpression = "aql:self." + s.getVal("target") + " + Sequence{target}";
		}
		chng.subModelOperations.add(uns);
		chng.subModelOperations.add(set);
	}
}

/*
 *----------------------------------------------------------------------------------
 *      CONDITIONAL STYLES
 *----------------------------------------------------------------------------------
 */	

@abstarct
rule ConditionalFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!ConditionalStyleDescription {
	guard : s.Source = "sirius.condition"
	t.predicateExpression = s.getVal("condition");
	} 
	
@lazy
rule ConditionalNodeFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!ConditionalNodeStyleDescription 
	extends ConditionalFromAnnotation {
		 t.style = annotations.selectOne(i|i.Source = "sirius.node.description" and i.getVal("node") = s.getVal("name")).equivalent();
	} 

@lazy
rule ConditionalContainerFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!ConditionalContainerStyleDescription 
	extends ConditionalFromAnnotation {
		 t.style = annotations.selectOne(i|i.Source = "sirius.container.description" and i.getVal("node") = s.getVal("name")).equivalent();
	} 
	
@lazy
rule ConditionalContainerFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!ConditionalEdgeStyleDescription 
	extends ConditionalFromAnnotation {
		 t.style = annotations.selectOne(i|i.Source = "sirius.edge.description" and i.getVal("node") = s.getVal("name")).equivalent();
	} 

/*
 *----------------------------------------------------------------------------------
 *      SHORTCUT TOOLS
 *----------------------------------------------------------------------------------
 */	


@abstract
rule ReferenceCreationToolFromAnnotation
	transform s : Source!EAnnotation 
	to t : Target!MappingBasedToolDescription {
	guard : s.Source = "sirius.tool.creation.reference" and not s.getVal("abstract").asBoolean()
	t.forceRefresh = true;
	t.name = "Add to " + s.eModelElement.name.ftuc();
	}

@lazy
rule ContainerReferenceCreationToolFromAnnotation
	transform s : Source!EAnnotation
	to t : Target!ToolDescription 
	extends ReferenceCreationToolFromAnnotation {
	guard : s.getVal("container") != ""
	
	var p = annotations.selectOne(i|i.getVal("name") = s.getVal("container"));
	t.precondition = "aql:elementView.actualMapping.name = '" + annotations.selectOne(i|i.getVal("name") = p.getVal("container")).equivalent().name + "'";
	var changeContext = new Target!ChangeContext;
	t.initialOperation = new Target!InitialOperation;
	t.initialOperation.firstModelOperations = changeContext;
	if (s.getVal("proxyType") =  "Container"){changeContext.browseExpression = "aql:element.eContainer()";}
	if (s.getVal("proxyType") =  "Diagram"){changeContext.browseExpression = "aql:diagram.target";}
	if (s.getVal("proxyType") =  "Personal"){changeContext.browseExpression = s.getVal("proxyStatement");}
	
	var create = new Target!CreateInstance;
	create.referenceName = p.eModelElement.name;
	create.typeName = p.eModelElement.eReferenceType.getDC();
	changeContext.subModelOperations.add(create);
	
	var refContext = new Target!ChangeContext;
	refContext.browseExpression = "aql:element";
	changeContext.subModelOperations.add(refContext);
	//TODO Check that this works if it is only able to hold one reference
	var setRef = new Target!SetValue;
	setRef.featureName = s.eModelElement.name;
	setRef.valueExpression = "aql: element." + s.eModelElement.name + " + Sequence{instance}";
	refContext.subModelOperations.add(setRef);
	}

@abstract
rule CreationToolFromAnnotation
	transform s : Source!EAnnotation 
	to t : Target!MappingBasedToolDescription {
	guard : s.Source = "sirius.tool.creation" and not s.getVal("abstract").asBoolean()
	t.forceRefresh = true;
	t.name = "Add to " + s.getVal("name").ftuc();
	}

@lazy
rule ContainerCreationToolFromAnnotation
	transform s : Source!EAnnotation
	to t : Target!ContainerCreationDescription 
	extends CreationToolFromAnnotation {
	guard : s.getVal("container") != "" and annotations.selectOne(i|i.getVal("name") = s.getVal("container")).Source = "sirius.container"
	var element = annotations.select(i|i.getVal("name") = s.getVal("container"));
	t.containerMappings = element.equivalent();
	var changeContext = new Target!ChangeContext;
	t.initialOperation = new Target!InitialNodeCreationOperation;
	changeContext.browseExpression = "var:container";
	t.initialOperation.firstModelOperations = changeContext;
	var create = new Target!CreateInstance;
	create.referenceName = s.eModelElement.name;
	create.typeName = element.random().eModelElement.getDC();
	changeContext.subModelOperations.add(create);
	}
	
@lazy
rule NodeCreationToolFromAnnotation
	transform s : Source!EAnnotation
	to t : Target!NodeCreationDescription 
	extends CreationToolFromAnnotation {
	guard : s.getVal("container") != "" and annotations.selectOne(i|i.getVal("name") = s.getVal("container")).Source = "sirius.node"
	var element = annotations.select(i|i.getVal("name") = s.getVal("container"));
	t.nodeMappings = element.equivalent();
	var changeContext = new Target!ChangeContext;
	t.initialOperation = new Target!InitialNodeCreationOperation;
	changeContext.browseExpression = "var:container";
	t.initialOperation.firstModelOperations = changeContext;
	var create = new Target!CreateInstance;
	create.referenceName = s.eModelElement.name;
	create.typeName = element.random().eModelElement.getDC();
	changeContext.subModelOperations.add(create);
	}

/*
 *----------------------------------------------------------------------------------
 *      SIRIUS IMPORTS
 *----------------------------------------------------------------------------------
 */	

@abstract
rule AbstractMappingImportFromAnnotation
	transform s : Source!EAnnotation
	to t : Target!AbstractMappingImport{
	guard : s.Source.endsWith("import")
	t.hideSubMappings = s.getVal("hideSubMappings");
	t.inheritsAncestorFilters = s.getVal("inheritsAncestorFilters");
	}

@lazy
rule ImportNodeFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!NodeMappingImport
	extends AbstractNodeFromAnnotation, AbstractMappingImportFromAnnotation{
	importedMapping = annotations.select(i|i.getVal("name") = s.getVal("importedMapping")).selectOne(i|i.Source = "sirius.node").equivalent();
	}

/*
 *----------------------------------------------------------------------------------
 *      ABSTRACT META SIRIUS STYLES 
 *----------------------------------------------------------------------------------
 */	

@abstract
rule BorderedStyleFromAnnotation
	transform s : Source!EAnnotation
	to t : Target!BorderedStyleDescription{
	t.borderColor = s.getVal("borderColor").getColor();
	t.borderLineStyle = Target!LineStyle#dot.VALUES.selectOne(i|i.literal = s.getVal("borderLineStyle"));
	t.borderSizeComputationExpression = "aql:" + s.getVal("borderSize");
	}
	
@abstract
rule LabelStyleFromAnnotation
	transform s : Source!EAnnotation
	to t : Target!LabelStyleDescription{
	t.iconPath = s.getVal("iconPath");
	t.labelAlignment = Target!LabelAlignment#CENTER.VALUES.selectOne(i|i.literal = s.getVal("labelAlignment"));
	t.labelColor = s.getVal("labelColor").getColor();
	t.labelExpression = s.getVal("proLabelExpression");
	t.labelFormat = Target!FontFormat#bold.VALUES.select(i|s.getVals("borderLineStyle").exists(j|j = i.literal));
	t.labelSize = s.getVal("labelSize").asInteger();
	t.showIcon = s.getVal("showIcon").asBoolean();
	}

@abstract
rule TooltipFromAnnotation
	transform s : Source!EAnnotation
	to t : Target!TooltipStyleDescription{
	t.tooltipExpression = s.getVal("tooltip");
	}
	
@abstract
rule RoundedCornerFromAnnotation
	transform s : Source!EAnnotation
	to t : Target!TooltipStyleDescription{
	t.arcHeight = s.getVal("arcHeight").asInteger();
	t.arcWidth = s.getVal("arcWidth").asInteger();
	}

/*
 *----------------------------------------------------------------------------------
 *      ABSTRACT SIRIUS STYLES 
 *----------------------------------------------------------------------------------
 */	

@abstract
rule NodeStyleFromAnnotation
	transform s : Source!EAnnotation
	to t : Target!NodeStyleDescription
	extends BorderedStyleFromAnnotation, LabelStyleFromAnnotation , TooltipFromAnnotation
	{
	guard : (s.source = "sirius.node.description" or s.source = "sirius.border.description") and (not s.getVal("abstract").asBoolean())
	t.forbiddenSides = Target!Side#NORTH.VALUES.select(i|s.getVals("forbiddenSides").exists(j|j = i.literal));
 	t.hideLabelByDefault = s.getVal("hideLabelByDefault").asBoolean();
 	t.iconPath = s.getVal("iconPath");
 	t.labelPosition = Target!LabelPosition#node.VALUES.selectOne(i|i.literal = s.getVal("labelPosition"));
 	t.resizeKind = Target!ResizeKind#NSEW.VALUES.selectOne(i|i.literal = s.getVal("resizeKind"));
	t.sizeComputationExpression = s.getVal("sizeComputationExpression");
	}
	
@abstract
rule ContainerStyleFromAnnotation
	transform s : Source!EAnnotation
	to t : Target!ContainerStyleDescription
	extends BorderedStyleFromAnnotation, LabelStyleFromAnnotation , TooltipFromAnnotation , RoundedCornerFromAnnotation
	{
	guard : s.source = "sirius.container.description" and not s.getVal("abstract").asBoolean()
 	t.hideLabelByDefault = s.getVal("hideLabelByDefault","false").asBoolean();
 	t.iconPath = s.getVal("iconPath");
	t.heightComputationExpression = s.getVal("heightComputationExpression");
	t.widthComputationExpression = s.getVal("widthComputationExpression");
	t.roundedCorner = s.getVal("roundedCorner").asBoolean();

	}
	
/*
 *----------------------------------------------------------------------------------
 *      SIRIUS STYLES 
 *----------------------------------------------------------------------------------
 */		
	
@lazy
rule FlatContainerFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!FlatContainerStyleDescription 
	extends ContainerStyleFromAnnotation{
	guard : s.getVal("shape") = "flat" or s.getVal("shape") = ""
	
	t.backgroundColor = s.getVal("backgroundColor").getColor();
	t.foregroundColor = s.getVal("foregroundColor").getColor();
	t.backgroundStyle = Target!BackgroundStyle#Liquid.VALUES.selectOne(i|i.literal = s.getVal("backgroundStyle","GradientLeftToRight"));
	
	}
	
@lazy
rule ShapeContainerFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!ShapeContainerStyleDescription 
	extends ContainerStyleFromAnnotation{
	guard : s.getVal("shape") = "shape"
	
	t.backgroundColor = s.getVal("color", "lightYellow").getColor();
	//Pointless
	t.shape = Target!ContainerShape#parallelogram.VALUES.selectOne(i|i.literal = s.getVal("shape","parallelogram"));
	
	}

@lazy
rule SquareNodeFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!SquareDescription 
	extends NodeStyleFromAnnotation{
	guard : s.getVal("shape") = "square" or s.getVal("shape") = ""
	
	t.color = s.getVal("color").getColor();
	t.height = s.getVal("height").asInteger();
	t.width = s.getVal("width").asInteger();
	
	}
	
@lazy
rule DotNodeFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!DotDescription 
	extends NodeStyleFromAnnotation{
	guard : s.getVal("shape") = "dot"
	
	t.backgroundColor = s.getVal("color").getColor();
	t.strokeSizeComputationExpression = s.getVal("strokeSizeComputationExpression","2");
	}
	
@lazy
rule EllipseNodeFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!EllipseNodeDescription 
	extends NodeStyleFromAnnotation{
	guard : s.getVal("shape") = "ellipse"
	//Maybe make a colourable rule
	t.color = s.getVal("color").getColor();
	t.horizontalDiameterComputationExpression = s.getVal("horizontalDiameterComputationExpression","2");
	t.verticalDiameterComputationExpression = s.getVal("verticalDiameterComputationExpression","2");
	}
	
//@lazy
//rule GaugeNodeFromAnnotation
//	transform 	s : Source!EAnnotation
//	to 			t : Target!GuageDescription 
//	extends NodeStyleFromAnnotation{
//	guard : s.getVal("shape") = "ellipse"
//	
//	t.alightment Enum
//	}

@lazy
rule LozengeNodeFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!LozengeNodeDescription 
	extends NodeStyleFromAnnotation{
	guard : s.getVal("shape") = "ellipse"
	//Maybe make a colourable rule
	t.color = s.getVal("color").getColor();
	t.heightComputationExpression = s.getVal("heightComputationExpression","2");
	t.widthComputationExpression = s.getVal("widthComputationExpression","2");
	}
	
@lazy
rule WorkspaceImageNodeFromAnnotation
	transform 	s : Source!EAnnotation
	to 			t : Target!WorkspaceImageDescription
	extends NodeStyleFromAnnotation
{
	guard : s.getVal("shape") = "image"
	
	t.workspacePath = s.getVal("imagePath");
	}

	
post {
	var gotHidden = new Sequence;
	for (tool in hiddenTools.keySet()){
		if (not gotHidden.contains(hiddenTools.get(tool))){
			gotHidden.add(hiddenTools.get(tool));
			var hiddenBox = new Target!ToolSection;
			hiddenBox.name = "Generated Hidden Tools";
			hiddenTools.get(tool).equivalent().defaultLayer.toolSections.add(hiddenBox);
		}
		hiddenTools.get(tool).equivalent().defaultLayer.toolSections.selectOne(i|i.name = "Generated Hidden Tools").ownedTools.add(tool);
	}
}	